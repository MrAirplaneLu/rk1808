2018-07-28
transmit程序设计初衷：
有的低端设备（如ARM9开发板）运行不了openssl，只能实现socket，甚至更加低端一点的设备（如89C51、STM32）只能运行串口，但是很多场合需要加密，如pos机对银行卡读取服务，所以此程序设计的目的是为了这些设备能够通过一个运行着openssl的加密设备实现若干条加密通信，达到节约成本、安全可靠的信息传递。（串口和socket的相互转换时另一个程序）



transmit程序实现功能：
1、把来自普通的socket client的信息通过transmit转换为加密的信息传递给server SSL。

2、把来自加密的server SSL的信息通过transmit转换为普通的信息传递给socket client。

3、实现双方实时通信（需要换行符刷新显示）。

4、实现reverse逆序功能，启用后可以直接把来自socket client的信息逆序之后返回回去（在server SSL实现）。



程序实现中遇到的麻烦：
1、入口参数的问题：入口参数项设置端口和地址；transmit中client和server因为参数列表的差异不能同时初始化。
解决：设计入口参数，限制输入情况

2、transmit中的socket server端既要等待连接，又要传输数据，还要创建client SSL线程，只用单线程模型完成不了，而且传输过程中数据会冲突。
解决：使用多进程模型去传输数据，再用多线程去创建client SSL，这样数据不冲突。

3、第二个问题中的多线程的fd在后续的client SSL中始终是bad filedescriptor。
解决：最开始是以为SSL初始化和设置不正确，检查了几十遍，去用未加进程和线程模型的程序试验，并没有出错。历经十几个小时才发现，accept_fd在父线程中被关闭了，只要取消父线程的close()，只让子线程取关闭就好了。（之前的程序未加close()语句，导致fd在累加，给自己提个醒记得关闭，现在反而还影响了自己。）

4、第三个问题中，引入多进程之后，子进程在两层while(1)中无法跳出。
解决：起初想用goto语句，但是担心不安全。检查之后，其实只有一层while(1)在起作用，稍微优化了一下就修复了。

5、read和write不能随心所欲的控制。
解决：使用select多路复用，提高效率，不用以回车去强制刷新。

6、多线程模型中的参数列表是(void *)，对传参不理解。
解决：之前的方法是传入(void **argv)，可以对多个数据用argv[0]、argv[1]等等操作。但是现在是传入参数是结构体，无法操作，后来进一步学习了pthread的传参方法：info *info_set = (info *)argv; 就真正解决了。

7、增加了从标准输入读取之后，屏幕无限刷新。
解决：是我理解的问题，不是对fd = 0进行select write限制，因为fd = 0是一直准备就绪的，实际上是应该对socket的fd进行多路复用。

8、用select多路复用去阻塞ssl的读写，却提示错误：SSL *是一个结构体。
解决：仔细查看struct SSL结构体，找出SSL_get_fd()函数获取fd。

9、无法判断client端是否断开连接。
解决：仔细查看read()函数的系统调用，了解到read()的返回值为-1不仅仅只是出错，而且可以用来判断对方是否断开连接。

10、transmit中的数据要双向传递，所以局部变量是传不过去的，尽管只是需要值传递就行，但是觉得不好用。
解决：直接上升到全局变量，就不用操心传参的麻烦。



未解决：
1、标准输入阻塞问题，只有输入回车符才能刷新屏幕。
想法：使用的fgets()从标准输入读取，结果导致阻塞，之后换成不阻塞的getchar()，实际上还是会阻塞控制台的，最后无法解决。
提高：之前把回车符作为结束，导致换行刷新会发送回车符，导致printf了一次send，现在改成只有回车符不当成send，即优化了效率，也让刷新更直观。

2、server SSL的命令行传参没有加入“证书”。
想法：server SSL端的传参已经有所限制，再增加输入“证书路径”不是很难，只不过还不考虑加上。



满意：
1、加入了打印证书信息的函数。

2、加入了输入“quit”就能终止信息传递并断开连接。

3、加入了对端口号port进行判断，只能输入全数字。

4、改进成只输入回车不传数据、不打印，有利于界面美观。

5、增加了逆序函数，开启之后server SSL将会把从client传来的数据进行逆序，并且返回回去，实现自测功能。

6、基本信息全部用结构体设置，通篇都是结构体。

7、main()函数只有最少的代码，功能都尽量封装到函数去。

8、编译只用makefile完成，证书生成只用creat_key.sh脚本完成。

2018-08-09
改进：
1、在了解了socket信息传递只需要知道fd之后，我把多进程优化成多线程，并取消全局变量。

2、修改了最大只能打开1024个文件描述符的限制---setrlimit。

3、优化了server端终止之后短时间端口被占用问题---setsockopt。

4、去掉了server_SSL端的标准输入，只留下了逆序回复。
                                                  Designed  by  YuJie 





